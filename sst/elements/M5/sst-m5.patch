diff -r -x '*.pyc' -u /home/mjleven/tmp/m5/src/arch/alpha/linux/linux.cc src/arch/alpha/linux/linux.cc
--- /home/mjleven/tmp/m5/src/arch/alpha/linux/linux.cc	2010-10-20 13:51:48.000000000 -0600
+++ src/arch/alpha/linux/linux.cc	2011-04-22 10:37:05.000000000 -0600
@@ -61,6 +61,7 @@
   { AlphaLinux::TGT_O_EXCL,     O_EXCL },
   { AlphaLinux::TGT_O_NONBLOCK, O_NONBLOCK },
   { AlphaLinux::TGT_O_NOCTTY,   O_NOCTTY },
+  { AlphaLinux::TGT_O_DRD,   O_DIRECTORY },
 #ifdef O_SYNC
   { AlphaLinux::TGT_O_SYNC,     O_SYNC },
 #endif
diff -r -x '*.pyc' -u /home/mjleven/tmp/m5/src/arch/alpha/linux/process.cc src/arch/alpha/linux/process.cc
--- /home/mjleven/tmp/m5/src/arch/alpha/linux/process.cc	2010-10-20 13:51:48.000000000 -0600
+++ src/arch/alpha/linux/process.cc	2011-07-05 10:39:17.000000000 -0600
@@ -563,7 +563,9 @@
     /* 438 */ SyscallDesc("waitid", unimplementedFunc),
     /* 439 */ SyscallDesc("add_key", unimplementedFunc),
     /* 440 */ SyscallDesc("request_key", unimplementedFunc),
-    /* 441 */ SyscallDesc("keyctl", unimplementedFunc)
+    /* 441 */ SyscallDesc("keyctl", unimplementedFunc),
+    /* 442 */ SyscallDesc("virt2phys", virt2physFunc),
+    /* 443 */ SyscallDesc("mmap_dev", mmap_devFunc)
 };
 
 AlphaLinuxProcess::AlphaLinuxProcess(LiveProcessParams * params,
diff -r -x '*.pyc' -u /home/mjleven/tmp/m5/src/arch/alpha/tlb.cc src/arch/alpha/tlb.cc
--- /home/mjleven/tmp/m5/src/arch/alpha/tlb.cc	2010-10-20 13:51:48.000000000 -0600
+++ src/arch/alpha/tlb.cc	2011-05-02 09:10:18.000000000 -0600
@@ -233,6 +233,19 @@
             return new UnimpFault("CPU trying to fetch from uncached I/O");
 
     }
+#if 1 
+    if ( req->getPaddr() < 0x10000 ) {
+	    //DPRINTFN("TLB::%s() don't cache %#lx\n",__func__,req->getPaddr());
+        req->setFlags(Request::UNCACHEABLE);
+    }
+#endif
+#if 0 
+    if ( req->getPaddr() >= 0x20000000 && req->getPaddr() < 0x30000000 ) {
+//	    fprintf(stderr,"TLB::%s() don't cache %#lx\n",__func__,req->getPaddr());
+        req->setFlags(Request::UNCACHEABLE);
+    }
+#endif
+
     return NoFault;
 }
 
diff -r -x '*.pyc' -u /home/mjleven/tmp/m5/src/cpu/intr_control.cc src/cpu/intr_control.cc
--- /home/mjleven/tmp/m5/src/cpu/intr_control.cc	2010-10-20 13:51:49.000000000 -0600
+++ src/cpu/intr_control.cc	2011-03-24 08:32:20.000000000 -0600
@@ -50,7 +50,7 @@
     DPRINTF(IntrControl, "post  %d:%d (cpu %d)\n", int_num, index, cpu_id);
     std::vector<ThreadContext *> &tcvec = sys->threadContexts;
     BaseCPU *cpu = tcvec[cpu_id]->getCpuPtr();
-    cpu->postInterrupt(int_num, index);
+    //cpu->postInterrupt(int_num, index);
 }
 
 void
@@ -59,7 +59,7 @@
     DPRINTF(IntrControl, "clear %d:%d (cpu %d)\n", int_num, index, cpu_id);
     std::vector<ThreadContext *> &tcvec = sys->threadContexts;
     BaseCPU *cpu = tcvec[cpu_id]->getCpuPtr();
-    cpu->clearInterrupt(int_num, index);
+    //cpu->clearInterrupt(int_num, index);
 }
 
 IntrControl *
diff -r -x '*.pyc' -u /home/mjleven/tmp/m5/src/cpu/SConscript src/cpu/SConscript
--- /home/mjleven/tmp/m5/src/cpu/SConscript	2010-10-20 13:51:49.000000000 -0600
+++ src/cpu/SConscript	2011-03-21 09:04:00.000000000 -0600
@@ -136,6 +136,10 @@
         SimObject('LegionTrace.py')
         Source('legiontrace.cc')
 
+if env['FULL_SYSTEM'] == 0:
+    SimObject('IntrControl.py')
+    Source('intr_control.cc')
+
 if env['TARGET_ISA'] == 'x86':
     SimObject('NativeTrace.py')
     Source('nativetrace.cc')
diff -r -x '*.pyc' -u /home/mjleven/tmp/m5/src/dev/SConscript src/dev/SConscript
--- /home/mjleven/tmp/m5/src/dev/SConscript	2010-10-20 13:51:49.000000000 -0600
+++ src/dev/SConscript	2011-03-21 09:02:11.000000000 -0600
@@ -106,3 +106,10 @@
         'EthernetIntr', 'EthernetSM', 'EthernetCksum' ])
     CompoundFlag('IdeAll', [ 'IdeCtrl', 'IdeDisk' ])
 
+if env['FULL_SYSTEM'] == 0:
+    SimObject('Device.py')
+    SimObject('Platform.py')
+    TraceFlag('DMA')
+    TraceFlag('IsaFake')
+    Source('io_device.cc')
+    Source('isa_fake.cc')
diff -r -x '*.pyc' -u /home/mjleven/tmp/m5/src/mem/cache/cache_impl.hh src/mem/cache/cache_impl.hh
--- /home/mjleven/tmp/m5/src/mem/cache/cache_impl.hh	2010-10-20 13:51:49.000000000 -0600
+++ src/mem/cache/cache_impl.hh	2011-07-18 13:05:23.000000000 -0600
@@ -1101,6 +1101,18 @@
     bool have_exclusive = blk->isWritable();
     bool invalidate = pkt->isInvalidate();
 
+    if ( pkt->isWrite() ) {
+	    DPRINTF( Cache, "%s()\n",pkt->getAddr() );
+        printf("%s:Cache::%s() `%s` %#lx\n",name().c_str(),__func__,
+                pkt->isRequest() ? "Request" : "Response", pkt->getAddr() );
+        pkt->writeDataToBlock(blk->data, blkSize);
+
+        if ( ! respond ) {
+            assert(!pkt->memInhibitAsserted());
+            pkt->assertMemInhibit();
+        }
+    }
+
     if (pkt->isRead() && !pkt->isInvalidate()) {
         assert(!pkt->needsExclusive());
         pkt->assertShared();
diff -r -x '*.pyc' -u /home/mjleven/tmp/m5/src/mem/packet.hh src/mem/packet.hh
--- /home/mjleven/tmp/m5/src/mem/packet.hh	2010-10-20 13:51:49.000000000 -0600
+++ src/mem/packet.hh	2011-03-24 08:22:29.000000000 -0600
@@ -384,6 +384,8 @@
      */
     SenderState *senderState;
 
+    FlagsType getFlags() const { return flags; } 
+
     /// Return the string name of the cmd field (for debugging and
     /// tracing).
     const std::string &cmdString() const { return cmd.toString(); }
diff -r -x '*.pyc' -u /home/mjleven/tmp/m5/src/mem/page_table.cc src/mem/page_table.cc
--- /home/mjleven/tmp/m5/src/mem/page_table.cc	2010-10-20 13:51:49.000000000 -0600
+++ src/mem/page_table.cc	2011-07-01 10:33:53.000000000 -0600
@@ -65,6 +65,31 @@
 }
 
 void
+PageTable::map(Addr vaddr, Addr paddr, int64_t size)
+{
+    // starting address must be page aligned
+    assert(pageOffset(vaddr) == 0);
+
+    DPRINTF(MMU, "Mapping Page: %#x-%#x -> %#x-%#x\n", 
+		vaddr, vaddr+ size, paddr, paddr+ size);
+
+    for (; size > 0; size -= pageSize, vaddr += pageSize, paddr += pageSize) {
+        PTableItr iter = pTable.find(vaddr);
+
+        if (iter != pTable.end()) {
+            // already mapped
+            fatal("PageTable::allocate: address 0x%x already mapped",
+                    vaddr);
+        }
+
+        pTable[vaddr] = TheISA::TlbEntry(process->M5_pid, vaddr, paddr );
+        DPRINTF(MMU,"Mapping %#lx %#lx\n", vaddr, paddr);
+        updateCache(vaddr, pTable[vaddr]);
+        if ( process->nicMmu ) process->nicMmu->add( vaddr, paddr );
+    }
+}
+
+void
 PageTable::allocate(Addr vaddr, int64_t size)
 {
     // starting address must be page aligned
@@ -81,9 +106,10 @@
                     vaddr);
         }
 
-        pTable[vaddr] = TheISA::TlbEntry(process->M5_pid, vaddr,
-                process->system->new_page());
+        Addr paddr = process->system->new_page();
+        pTable[vaddr] = TheISA::TlbEntry(process->M5_pid, vaddr, paddr );
         updateCache(vaddr, pTable[vaddr]);
+        if ( process->nicMmu ) process->nicMmu->add( vaddr, paddr );
     }
 }
 
diff -r -x '*.pyc' -u /home/mjleven/tmp/m5/src/mem/page_table.hh src/mem/page_table.hh
--- /home/mjleven/tmp/m5/src/mem/page_table.hh	2010-10-20 13:51:49.000000000 -0600
+++ src/mem/page_table.hh	2011-03-21 13:01:39.000000000 -0600
@@ -79,6 +79,7 @@
     Addr pageAlign(Addr a)  { return (a & ~offsetMask); }
     Addr pageOffset(Addr a) { return (a &  offsetMask); }
 
+    void map(Addr vaddr, Addr paddr, int64_t size);
     void allocate(Addr vaddr, int64_t size);
     void remap(Addr vaddr, int64_t size, Addr new_vaddr);
     void deallocate(Addr vaddr, int64_t size);
diff -r -x '*.pyc' -u /home/mjleven/tmp/m5/src/mem/physical.cc src/mem/physical.cc
--- /home/mjleven/tmp/m5/src/mem/physical.cc	2010-10-20 13:51:49.000000000 -0600
+++ src/mem/physical.cc	2011-07-18 13:03:27.000000000 -0600
@@ -54,7 +54,8 @@
 PhysicalMemory::PhysicalMemory(const Params *p)
     : MemObject(p), pmemAddr(NULL), pagePtr(0),
       lat(p->latency), lat_var(p->latency_var),
-      cachedSize(params()->range.size()), cachedStart(params()->range.start)
+      cachedSize(params()->range.size()), cachedStart(params()->range.start),
+    m_idx(0)
 {
     if (params()->range.size() % TheISA::PageBytes != 0)
         panic("Memory Size not divisible by page size\n");
         panic("PhysicalMemory::getPort: unknown port %s requested", if_name);
     }
 
+    if ( idx == -1 ) idx = m_idx++;
+
     if (idx >= (int)ports.size()) {
         ports.resize(idx + 1);
     }
diff -r -x '*.pyc' -u /home/mjleven/tmp/m5/src/mem/physical.hh src/mem/physical.hh
--- /home/mjleven/tmp/m5/src/mem/physical.hh	2010-10-20 13:51:49.000000000 -0600
+++ src/mem/physical.hh	2011-07-18 13:03:42.000000000 -0600
@@ -151,6 +151,7 @@
 
     uint64_t cachedSize;
     uint64_t cachedStart;
+    int m_idx;
   public:
     Addr new_page();
     uint64_t size() { return cachedSize; }
Only in src: patch
diff -r -x '*.pyc' -u /home/mjleven/tmp/m5/src/SConscript src/SConscript
--- /home/mjleven/tmp/m5/src/SConscript	2010-10-20 13:51:48.000000000 -0600
+++ src/SConscript	2011-03-15 15:09:39.000000000 -0600
@@ -99,7 +99,7 @@
         
 class Source(SourceFile):
     '''Add a c/c++ source file to the build'''
-    def __init__(self, source, Werror=True, swig=False, bin_only=False,
+    def __init__(self, source, Werror=False, swig=False, bin_only=False,
                  skip_lib=False):
         super(Source, self).__init__(source)
 
@@ -946,14 +946,14 @@
     new_env.Append(**kwargs)
 
     swig_env = new_env.Clone()
-    swig_env.Append(CCFLAGS='-Werror')
+    #swig_env.Append(CCFLAGS='-Werror')
     if env['GCC']:
         swig_env.Append(CCFLAGS='-Wno-uninitialized')
         swig_env.Append(CCFLAGS='-Wno-sign-compare')
         swig_env.Append(CCFLAGS='-Wno-parentheses')
 
     werror_env = new_env.Clone()
-    werror_env.Append(CCFLAGS='-Werror')
+    #werror_env.Append(CCFLAGS='-Werror')
 
     def make_obj(source, static, extra_deps = None):
         '''This function adds the specified source to the correct
Only in src/sim: nicMmu.h
diff -r -x '*.pyc' -u /home/mjleven/tmp/m5/src/sim/process.cc src/sim/process.cc
--- /home/mjleven/tmp/m5/src/sim/process.cc	2010-10-20 13:51:49.000000000 -0600
+++ src/sim/process.cc	2011-06-13 09:09:53.000000000 -0600
@@ -98,7 +98,9 @@
 
 Process::Process(ProcessParams * params)
     : SimObject(params), system(params->system), checkpointRestored(false),
-    max_stack_size(params->max_stack_size)
+    max_stack_size(params->max_stack_size),
+    nicMmu( NULL ),
+    nid(params->nid)
 {
     string in = params->input;
     string out = params->output;
@@ -170,7 +172,6 @@
     // other parameters will be initialized when the program is loaded
 }
 
-
 void
 Process::regStats()
 {
@@ -247,6 +248,12 @@
             TranslatingPort::Always);
     mem_port->setPeer(initVirtMem);
     initVirtMem->setPeer(mem_port);
+
+    if ( tc->getProcessPtr() && nid > -1 ) {
+        std::stringstream tmp;
+        tmp << "/pTable." << nid;
+        nicMmu = new NicMmu( tmp.str(), false );
+    }
 }
 
 // map simulator fd sim_fd to target fd tgt_fd
diff -r -x '*.pyc' -u /home/mjleven/tmp/m5/src/sim/process.hh src/sim/process.hh
--- /home/mjleven/tmp/m5/src/sim/process.hh	2010-10-20 13:51:49.000000000 -0600
+++ src/sim/process.hh	2011-06-01 08:08:14.000000000 -0600
@@ -49,6 +49,7 @@
 #include "base/types.hh"
 #include "sim/sim_object.hh"
 #include "sim/syscallreturn.hh"
+#include "sim/nicMmu.h"
 
 class GDBListener;
 class PageTable;
@@ -123,6 +124,7 @@
 
     // The maximum size allowed for the stack.
     Addr max_stack_size;
+    NicMmu*  nicMmu;
 
     // addr to use for next stack region (for multithreaded apps)
     Addr next_thread_stack_base;
@@ -157,6 +159,7 @@
     //This id is assigned by m5 and is used to keep process' tlb entries
     //separated.
     uint64_t M5_pid;
+    int      nid;
 
     class FdMap
     {
diff -r -x '*.pyc' -u /home/mjleven/tmp/m5/src/sim/Process.py src/sim/Process.py
--- /home/mjleven/tmp/m5/src/sim/Process.py	2010-10-20 13:51:49.000000000 -0600
+++ src/sim/Process.py	2011-05-31 15:19:17.000000000 -0600
@@ -38,6 +38,7 @@
     errout = Param.String('cerr', 'filename for stderr')
     system = Param.System(Parent.any, "system process will run on")
     max_stack_size = Param.MemorySize('64MB', 'maximum size of the stack')
+    nid = Param.Int(0, 'node id')
 
 class LiveProcess(Process):
     type = 'LiveProcess'
diff -r -x '*.pyc' -u /home/mjleven/tmp/m5/src/sim/simulate.cc src/sim/simulate.cc
--- /home/mjleven/tmp/m5/src/sim/simulate.cc	2010-10-20 13:51:49.000000000 -0600
+++ src/sim/simulate.cc	2011-03-28 14:05:59.000000000 -0600
@@ -85,6 +85,11 @@
                 assert(limit_event->scheduled());
                 limit_event->squash();
                 hack_once("be nice to actually delete the event here");
+fprintf(stderr,"%s %s %d\n",se_event->getCause().c_str(),
+                    se_event->description(),
+                    se_event->getCode());
+            } else { 
+                se_event = NULL;
             }
 
             return se_event;
diff -r -x '*.pyc' -u /home/mjleven/tmp/m5/src/sim/syscall_emul.cc src/sim/syscall_emul.cc
--- /home/mjleven/tmp/m5/src/sim/syscall_emul.cc	2010-10-20 13:51:49.000000000 -0600
+++ src/sim/syscall_emul.cc	2011-07-05 10:36:48.000000000 -0600
@@ -67,6 +67,38 @@
         process->setSyscallReturn(tc, retval);
 }
 
+SyscallReturn
+mmap_devFunc(SyscallDesc *desc, int callnum, LiveProcess *process,
+                  ThreadContext *tc)
+{
+    uint64_t  paddr = process->getSyscallArg(tc, 0);
+    uint64_t  length = process->getSyscallArg(tc, 1);
+
+    Addr start = process->mmap_end;
+
+    DPRINTF(SyscallVerbose, "syscall %s (#%d) vaddr=%#lx paddr=%#lx"
+		" length=%#lx\n", desc->name, callnum, start, paddr, length);
+
+    length = roundUp(length, TheISA::VMPageSize);
+    process->pTable->map(start, paddr, length );
+    process->mmap_end += length;
+
+    return start;
+}
+
+
+SyscallReturn
+virt2physFunc(SyscallDesc *desc, int callnum, LiveProcess *process,
+                  ThreadContext *tc)
+{
+    uint64_t  addr = process->getSyscallArg(tc, 0);
+    DPRINTF(SyscallVerbose, "syscall %s (#%d) addr=%#lx\n",
+                                 desc->name, callnum, addr);
+
+    Addr paddr;
+    process->pTable->translate( process->getSyscallArg(tc, 0), paddr );
+    return paddr;
+}
 
 SyscallReturn
 unimplementedFunc(SyscallDesc *desc, int callnum, LiveProcess *process,
diff -r -x '*.pyc' -u /home/mjleven/tmp/m5/src/sim/syscall_emul.hh src/sim/syscall_emul.hh
--- /home/mjleven/tmp/m5/src/sim/syscall_emul.hh	2010-10-20 13:51:49.000000000 -0600
+++ src/sim/syscall_emul.hh	2011-07-05 10:37:05.000000000 -0600
@@ -61,6 +61,8 @@
 #include "mem/page_table.hh"
 #include "sim/process.hh"
 
+#include <sys/resource.h>
+
 ///
 /// System call descriptor.
 ///
@@ -176,6 +178,11 @@
 SyscallReturn unimplementedFunc(SyscallDesc *desc, int num,
                                 LiveProcess *p, ThreadContext *tc);
 
+SyscallReturn virt2physFunc(SyscallDesc *desc, int num,
+                                LiveProcess *p, ThreadContext *tc);
+SyscallReturn mmap_devFunc(SyscallDesc *desc, int num,
+                                LiveProcess *p, ThreadContext *tc);
+
 /// Handler for unimplemented syscalls that we never intend to
 /// implement (signal handling, etc.) and should not affect the correct
 /// behavior of the program.  Print a warning only if the appropriate
@@ -996,6 +1003,33 @@
             rlp->rlim_max = htog(rlp->rlim_max);
             break;
 
+        case OS::TGT_RLIMIT_NOFILE:
+{
+            struct rlimit rlim;
+            getrlimit( RLIMIT_NOFILE, &rlim );
+            rlp->rlim_cur = rlim.rlim_cur;
+            rlp->rlim_max = rlim.rlim_max;
+}
+            break;
+
+        case OS::TGT_RLIMIT_NPROC:
+{
+            struct rlimit rlim;
+            getrlimit( RLIMIT_NPROC, &rlim );
+            rlp->rlim_cur = rlim.rlim_cur;
+            rlp->rlim_max = rlim.rlim_max;
+}
+            break;
+
+        case OS::TGT_RLIMIT_FSIZE:
+{
+            struct rlimit rlim;
+            getrlimit( RLIMIT_FSIZE, &rlim );
+            rlp->rlim_cur = rlim.rlim_cur;
+            rlp->rlim_max = rlim.rlim_max;
+}
+            break;
+
         default:
             std::cerr << "getrlimitFunc: unimplemented resource " << resource
                 << std::endl;
diff -r -x '*.pyc' -u /home/mjleven/tmp/m5/src/sim/system.cc src/sim/system.cc
--- /home/mjleven/tmp/m5/src/sim/system.cc	2010-10-20 13:51:49.000000000 -0600
+++ src/sim/system.cc	2011-04-22 11:36:45.000000000 -0600
@@ -253,7 +253,7 @@
     ++page_ptr;
     if (return_addr >= physmem->size())
         fatal("Out of memory, please increase size of physical memory.");
-    return return_addr;
+    return physmem->start() + return_addr;
 }
 
 Addr
diff -r -x '*.pyc' -u /home/mjleven/tmp/m5/src/sim/system.hh src/sim/system.hh
--- /home/mjleven/tmp/m5/src/sim/system.hh	2010-10-20 13:51:49.000000000 -0600
+++ src/sim/system.hh	2011-04-20 10:16:51.000000000 -0600
@@ -89,7 +89,7 @@
     std::vector<ThreadContext *> threadContexts;
     int _numContexts;
 
-    ThreadContext *getThreadContext(ThreadID tid)
+    virtual ThreadContext *getThreadContext(ThreadID tid)
     {
         return threadContexts[tid];
     }
@@ -228,7 +228,7 @@
 
 #else
 
-    Addr new_page();
+    virtual Addr new_page();
 
 #endif // FULL_SYSTEM
 
