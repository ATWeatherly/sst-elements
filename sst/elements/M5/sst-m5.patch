diff -x '*.pyc' -rupN /home/mjleven/tmp/m5/src/arch/alpha/linux/linux.cc ./arch/alpha/linux/linux.cc
--- /home/mjleven/tmp/m5/src/arch/alpha/linux/linux.cc	2010-10-20 13:51:48.000000000 -0600
+++ ./arch/alpha/linux/linux.cc	2011-05-27 07:38:21.000000000 -0600
@@ -61,6 +61,7 @@ OpenFlagTransTable AlphaLinux::openFlagT
   { AlphaLinux::TGT_O_EXCL,     O_EXCL },
   { AlphaLinux::TGT_O_NONBLOCK, O_NONBLOCK },
   { AlphaLinux::TGT_O_NOCTTY,   O_NOCTTY },
+  { AlphaLinux::TGT_O_DRD,   O_DIRECTORY },
 #ifdef O_SYNC
   { AlphaLinux::TGT_O_SYNC,     O_SYNC },
 #endif
diff -x '*.pyc' -rupN /home/mjleven/tmp/m5/src/arch/alpha/linux/process.cc ./arch/alpha/linux/process.cc
--- /home/mjleven/tmp/m5/src/arch/alpha/linux/process.cc	2010-10-20 13:51:48.000000000 -0600
+++ ./arch/alpha/linux/process.cc	2011-05-27 07:38:21.000000000 -0600
@@ -563,7 +563,9 @@ SyscallDesc AlphaLinuxProcess::syscallDe
     /* 438 */ SyscallDesc("waitid", unimplementedFunc),
     /* 439 */ SyscallDesc("add_key", unimplementedFunc),
     /* 440 */ SyscallDesc("request_key", unimplementedFunc),
-    /* 441 */ SyscallDesc("keyctl", unimplementedFunc)
+    /* 441 */ SyscallDesc("keyctl", unimplementedFunc),
+    /* 442 */ SyscallDesc("virt2phys", virt2physFunc),
+    /* 443 */ SyscallDesc("mmap_dev", mmap_devFunc)
 };
 
 AlphaLinuxProcess::AlphaLinuxProcess(LiveProcessParams * params,
diff -x '*.pyc' -rupN /home/mjleven/tmp/m5/src/arch/alpha/tlb.cc ./arch/alpha/tlb.cc
--- /home/mjleven/tmp/m5/src/arch/alpha/tlb.cc	2010-10-20 13:51:48.000000000 -0600
+++ ./arch/alpha/tlb.cc	2011-05-27 07:38:21.000000000 -0600
@@ -233,6 +233,19 @@ TLB::checkCacheability(RequestPtr &req, 
             return new UnimpFault("CPU trying to fetch from uncached I/O");
 
     }
+#if 1 
+    if ( req->getPaddr() < 0x10000 ) {
+	    //DPRINTFN("TLB::%s() don't cache %#lx\n",__func__,req->getPaddr());
+        req->setFlags(Request::UNCACHEABLE);
+    }
+#endif
+#if 1 
+    if ( req->getPaddr() >= 0x20000000 && req->getPaddr() < 0x30000000 ) {
+//	    fprintf(stderr,"TLB::%s() don't cache %#lx\n",__func__,req->getPaddr());
+        req->setFlags(Request::UNCACHEABLE);
+    }
+#endif
+
     return NoFault;
 }
 
diff -x '*.pyc' -rupN /home/mjleven/tmp/m5/src/arch/x86/linux/syscalls.cc ./arch/x86/linux/syscalls.cc
--- /home/mjleven/tmp/m5/src/arch/x86/linux/syscalls.cc	2010-10-20 13:51:49.000000000 -0600
+++ ./arch/x86/linux/syscalls.cc	2011-05-27 09:36:29.000000000 -0600
@@ -500,7 +500,9 @@ SyscallDesc X86_64LinuxProcess::syscallD
     /* 269 */ SyscallDesc("faccessat", unimplementedFunc),
     /* 270 */ SyscallDesc("pselect6", unimplementedFunc),
     /* 271 */ SyscallDesc("ppoll", unimplementedFunc),
-    /* 272 */ SyscallDesc("unshare", unimplementedFunc)
+    /* 272 */ SyscallDesc("unshare", unimplementedFunc),
+    /* 273 */ SyscallDesc("virt2phys", virt2physFunc),
+    /* 274 */ SyscallDesc("mmap_dev", mmap_devFunc)
 };
 
 const int X86_64LinuxProcess::numSyscalls = 
diff -x '*.pyc' -rupN /home/mjleven/tmp/m5/src/arch/x86/tlb.cc ./arch/x86/tlb.cc
--- /home/mjleven/tmp/m5/src/arch/x86/tlb.cc	2010-10-20 13:51:49.000000000 -0600
+++ ./arch/x86/tlb.cc	2011-05-27 10:10:23.000000000 -0600
@@ -701,6 +701,19 @@ TLB::translate(RequestPtr req, ThreadCon
         req->setPaddr(x86LocalAPICAddress(tc->contextId(), paddr - baseAddr));
     }
 #endif
+#if 1 
+    if ( req->getPaddr() < 0x10000 ) {
+        //DPRINTFN("TLB::%s() don't cache %#lx\n",__func__,req->getPaddr());
+        req->setFlags(Request::UNCACHEABLE);
+    }
+#endif
+#if 1 
+    if ( req->getPaddr() >= 0x20000000 && req->getPaddr() < 0x30000000 ) {
+//      fprintf(stderr,"TLB::%s() don't cache %#lx\n",__func__,req->getPaddr());
+        req->setFlags(Request::UNCACHEABLE);
+    }
+#endif
+
     return NoFault;
 };
 
diff -x '*.pyc' -rupN /home/mjleven/tmp/m5/src/base/trace.cc ./base/trace.cc
--- /home/mjleven/tmp/m5/src/base/trace.cc	2010-10-20 13:51:49.000000000 -0600
+++ ./base/trace.cc	2011-05-27 07:38:21.000000000 -0600
@@ -92,6 +92,17 @@ dprintf(Tick when, const std::string &na
         args.push_front(when);
     }
 
+#if 1 
+    static int _rank = -1;
+    if ( _rank == - 1) {
+        char* tmp = getenv("RANK");
+        if ( tmp ) sscanf( tmp, "%d", &_rank );
+    }
+ 
+    fmt = "%d:" + fmt;
+    args.push_front(_rank);
+#endif
+
     fmt += format;
 
     ccprintf(os, fmt.c_str(), args);
diff -x '*.pyc' -rupN /home/mjleven/tmp/m5/src/cpu/intr_control.cc ./cpu/intr_control.cc
--- /home/mjleven/tmp/m5/src/cpu/intr_control.cc	2010-10-20 13:51:49.000000000 -0600
+++ ./cpu/intr_control.cc	2011-05-27 07:38:21.000000000 -0600
@@ -50,7 +50,7 @@ IntrControl::post(int cpu_id, int int_nu
     DPRINTF(IntrControl, "post  %d:%d (cpu %d)\n", int_num, index, cpu_id);
     std::vector<ThreadContext *> &tcvec = sys->threadContexts;
     BaseCPU *cpu = tcvec[cpu_id]->getCpuPtr();
-    cpu->postInterrupt(int_num, index);
+    //cpu->postInterrupt(int_num, index);
 }
 
 void
@@ -59,7 +59,7 @@ IntrControl::clear(int cpu_id, int int_n
     DPRINTF(IntrControl, "clear %d:%d (cpu %d)\n", int_num, index, cpu_id);
     std::vector<ThreadContext *> &tcvec = sys->threadContexts;
     BaseCPU *cpu = tcvec[cpu_id]->getCpuPtr();
-    cpu->clearInterrupt(int_num, index);
+    //cpu->clearInterrupt(int_num, index);
 }
 
 IntrControl *
diff -x '*.pyc' -rupN /home/mjleven/tmp/m5/src/cpu/SConscript ./cpu/SConscript
--- /home/mjleven/tmp/m5/src/cpu/SConscript	2010-10-20 13:51:49.000000000 -0600
+++ ./cpu/SConscript	2011-05-27 07:38:21.000000000 -0600
@@ -136,6 +136,10 @@ if env['FULL_SYSTEM']:
         SimObject('LegionTrace.py')
         Source('legiontrace.cc')
 
+if env['FULL_SYSTEM'] == 0:
+    SimObject('IntrControl.py')
+    Source('intr_control.cc')
+
 if env['TARGET_ISA'] == 'x86':
     SimObject('NativeTrace.py')
     Source('nativetrace.cc')
diff -x '*.pyc' -rupN /home/mjleven/tmp/m5/src/dev/SConscript ./dev/SConscript
--- /home/mjleven/tmp/m5/src/dev/SConscript	2010-10-20 13:51:49.000000000 -0600
+++ ./dev/SConscript	2011-05-27 07:38:21.000000000 -0600
@@ -106,3 +106,10 @@ if env['FULL_SYSTEM']:
         'EthernetIntr', 'EthernetSM', 'EthernetCksum' ])
     CompoundFlag('IdeAll', [ 'IdeCtrl', 'IdeDisk' ])
 
+if env['FULL_SYSTEM'] == 0:
+    SimObject('Device.py')
+    SimObject('Platform.py')
+    TraceFlag('DMA')
+    TraceFlag('IsaFake')
+    Source('io_device.cc')
+    Source('isa_fake.cc')
diff -x '*.pyc' -rupN /home/mjleven/tmp/m5/src/mem/cache/cache_impl.hh ./mem/cache/cache_impl.hh
--- /home/mjleven/tmp/m5/src/mem/cache/cache_impl.hh	2010-10-20 13:51:49.000000000 -0600
+++ ./mem/cache/cache_impl.hh	2011-05-27 07:38:21.000000000 -0600
@@ -1031,6 +1031,9 @@ doTimingSupplyResponse(PacketPtr req_pkt
     pkt->makeTimingResponse();
     if (pkt->isRead()) {
         pkt->setDataFromBlock(blk_data, blkSize);
+    } else if (pkt->isWrite()) {
+	    DPRINTF( Cache, "%s()\n",req_pkt->getAddr() );
+        req_pkt->writeDataToBlock(blk_data, blkSize);
     }
     if (pkt->cmd == MemCmd::ReadResp && pending_inval) {
         // Assume we defer a response to a read from a far-away cache
diff -x '*.pyc' -rupN /home/mjleven/tmp/m5/src/mem/packet.hh ./mem/packet.hh
--- /home/mjleven/tmp/m5/src/mem/packet.hh	2010-10-20 13:51:49.000000000 -0600
+++ ./mem/packet.hh	2011-05-27 07:38:21.000000000 -0600
@@ -384,6 +384,8 @@ class Packet : public FastAlloc, public 
      */
     SenderState *senderState;
 
+    FlagsType getFlags() const { return flags; } 
+
     /// Return the string name of the cmd field (for debugging and
     /// tracing).
     const std::string &cmdString() const { return cmd.toString(); }
diff -x '*.pyc' -rupN /home/mjleven/tmp/m5/src/mem/page_table.cc ./mem/page_table.cc
--- /home/mjleven/tmp/m5/src/mem/page_table.cc	2010-10-20 13:51:49.000000000 -0600
+++ ./mem/page_table.cc	2011-05-27 07:38:21.000000000 -0600
@@ -65,6 +65,30 @@ PageTable::~PageTable()
 }
 
 void
+PageTable::map(Addr vaddr, Addr paddr, int64_t size)
+{
+    // starting address must be page aligned
+    assert(pageOffset(vaddr) == 0);
+
+    DPRINTF(MMU, "Mapping Page: %#x-%#x -> %#x-%#x\n", 
+		vaddr, vaddr+ size, paddr, paddr+ size);
+
+    for (; size > 0; size -= pageSize, vaddr += pageSize, paddr += pageSize) {
+        PTableItr iter = pTable.find(vaddr);
+
+        if (iter != pTable.end()) {
+            // already mapped
+            fatal("PageTable::allocate: address 0x%x already mapped",
+                    vaddr);
+        }
+
+        pTable[vaddr] = TheISA::TlbEntry(process->M5_pid, vaddr, paddr );
+        DPRINTF(MMU,"Mapping %#lx %#lx\n", vaddr, paddr);
+        updateCache(vaddr, pTable[vaddr]);
+    }
+}
+
+void
 PageTable::allocate(Addr vaddr, int64_t size)
 {
     // starting address must be page aligned
diff -x '*.pyc' -rupN /home/mjleven/tmp/m5/src/mem/page_table.hh ./mem/page_table.hh
--- /home/mjleven/tmp/m5/src/mem/page_table.hh	2010-10-20 13:51:49.000000000 -0600
+++ ./mem/page_table.hh	2011-05-27 07:38:21.000000000 -0600
@@ -79,6 +79,7 @@ class PageTable
     Addr pageAlign(Addr a)  { return (a & ~offsetMask); }
     Addr pageOffset(Addr a) { return (a &  offsetMask); }
 
+    void map(Addr vaddr, Addr paddr, int64_t size);
     void allocate(Addr vaddr, int64_t size);
     void remap(Addr vaddr, int64_t size, Addr new_vaddr);
     void deallocate(Addr vaddr, int64_t size);
diff -x '*.pyc' -rupN /home/mjleven/tmp/m5/src/SConscript ./SConscript
--- /home/mjleven/tmp/m5/src/SConscript	2010-10-20 13:51:48.000000000 -0600
+++ ./SConscript	2011-05-27 07:38:21.000000000 -0600
@@ -99,7 +99,7 @@ class SourceFile(object):
         
 class Source(SourceFile):
     '''Add a c/c++ source file to the build'''
-    def __init__(self, source, Werror=True, swig=False, bin_only=False,
+    def __init__(self, source, Werror=False, swig=False, bin_only=False,
                  skip_lib=False):
         super(Source, self).__init__(source)
 
@@ -946,14 +946,14 @@ def makeEnv(label, objsfx, strip = False
     new_env.Append(**kwargs)
 
     swig_env = new_env.Clone()
-    swig_env.Append(CCFLAGS='-Werror')
+    #swig_env.Append(CCFLAGS='-Werror')
     if env['GCC']:
         swig_env.Append(CCFLAGS='-Wno-uninitialized')
         swig_env.Append(CCFLAGS='-Wno-sign-compare')
         swig_env.Append(CCFLAGS='-Wno-parentheses')
 
     werror_env = new_env.Clone()
-    werror_env.Append(CCFLAGS='-Werror')
+    #werror_env.Append(CCFLAGS='-Werror')
 
     def make_obj(source, static, extra_deps = None):
         '''This function adds the specified source to the correct
diff -x '*.pyc' -rupN /home/mjleven/tmp/m5/src/sim/simulate.cc ./sim/simulate.cc
--- /home/mjleven/tmp/m5/src/sim/simulate.cc	2010-10-20 13:51:49.000000000 -0600
+++ ./sim/simulate.cc	2011-05-27 07:38:21.000000000 -0600
@@ -85,6 +85,11 @@ simulate(Tick num_cycles)
                 assert(limit_event->scheduled());
                 limit_event->squash();
                 hack_once("be nice to actually delete the event here");
+fprintf(stderr,"%s %s %d\n",se_event->getCause().c_str(),
+                    se_event->description(),
+                    se_event->getCode());
+            } else { 
+                se_event = NULL;
             }
 
             return se_event;
diff -x '*.pyc' -rupN /home/mjleven/tmp/m5/src/sim/syscall_emul.cc ./sim/syscall_emul.cc
--- /home/mjleven/tmp/m5/src/sim/syscall_emul.cc	2010-10-20 13:51:49.000000000 -0600
+++ ./sim/syscall_emul.cc	2011-05-27 07:38:21.000000000 -0600
@@ -67,6 +67,37 @@ SyscallDesc::doSyscall(int callnum, Live
         process->setSyscallReturn(tc, retval);
 }
 
+SyscallReturn
+mmap_devFunc(SyscallDesc *desc, int callnum, LiveProcess *process,
+                  ThreadContext *tc)
+{
+    uint64_t  paddr = process->getSyscallArg(tc, 0);
+    uint64_t  length = process->getSyscallArg(tc, 1);
+
+    Addr start = process->mmap_end;
+
+    DPRINTF(SyscallVerbose, "syscall %s (#%d) vaddr=%#lx paddr=%#lx"
+		" length=%#lx\n", desc->name, callnum, start, paddr, length);
+
+    process->pTable->map(start, paddr, length );
+    process->mmap_end += length;
+
+    return start;
+}
+
+
+SyscallReturn
+virt2physFunc(SyscallDesc *desc, int callnum, LiveProcess *process,
+                  ThreadContext *tc)
+{
+    uint64_t  addr = process->getSyscallArg(tc, 0);
+    DPRINTF(SyscallVerbose, "syscall %s (#%d) addr=%#lx\n",
+                                 desc->name, callnum, addr);
+
+    Addr paddr;
+    process->pTable->translate( process->getSyscallArg(tc, 0), paddr );
+    return paddr;
+}
 
 SyscallReturn
 unimplementedFunc(SyscallDesc *desc, int callnum, LiveProcess *process,
diff -x '*.pyc' -rupN /home/mjleven/tmp/m5/src/sim/syscall_emul.hh ./sim/syscall_emul.hh
--- /home/mjleven/tmp/m5/src/sim/syscall_emul.hh	2010-10-20 13:51:49.000000000 -0600
+++ ./sim/syscall_emul.hh	2011-05-27 07:38:21.000000000 -0600
@@ -61,6 +61,8 @@
 #include "mem/page_table.hh"
 #include "sim/process.hh"
 
+#include <sys/resource.h>
+
 ///
 /// System call descriptor.
 ///
@@ -176,6 +178,11 @@ class TypedBufferArg : public BaseBuffer
 SyscallReturn unimplementedFunc(SyscallDesc *desc, int num,
                                 LiveProcess *p, ThreadContext *tc);
 
+SyscallReturn virt2physFunc(SyscallDesc *desc, int num,
+                                LiveProcess *p, ThreadContext *tc);
+SyscallReturn mmap_devFunc(SyscallDesc *desc, int num,
+                                LiveProcess *p, ThreadContext *tc);
+
 /// Handler for unimplemented syscalls that we never intend to
 /// implement (signal handling, etc.) and should not affect the correct
 /// behavior of the program.  Print a warning only if the appropriate
@@ -996,6 +1003,33 @@ getrlimitFunc(SyscallDesc *desc, int cal
             rlp->rlim_max = htog(rlp->rlim_max);
             break;
 
+        case OS::TGT_RLIMIT_NOFILE:
+{
+            struct rlimit rlim;
+            getrlimit( RLIMIT_NOFILE, &rlim );
+            rlp->rlim_cur = rlim.rlim_cur;
+            rlp->rlim_max = rlim.rlim_max;
+}
+            break;
+
+        case OS::TGT_RLIMIT_NPROC:
+{
+            struct rlimit rlim;
+            getrlimit( RLIMIT_NPROC, &rlim );
+            rlp->rlim_cur = rlim.rlim_cur;
+            rlp->rlim_max = rlim.rlim_max;
+}
+            break;
+
+        case OS::TGT_RLIMIT_FSIZE:
+{
+            struct rlimit rlim;
+            getrlimit( RLIMIT_FSIZE, &rlim );
+            rlp->rlim_cur = rlim.rlim_cur;
+            rlp->rlim_max = rlim.rlim_max;
+}
+            break;
+
         default:
             std::cerr << "getrlimitFunc: unimplemented resource " << resource
                 << std::endl;
diff -x '*.pyc' -rupN /home/mjleven/tmp/m5/src/sim/system.cc ./sim/system.cc
--- /home/mjleven/tmp/m5/src/sim/system.cc	2010-10-20 13:51:49.000000000 -0600
+++ ./sim/system.cc	2011-05-27 07:38:21.000000000 -0600
@@ -253,7 +253,7 @@ System::new_page()
     ++page_ptr;
     if (return_addr >= physmem->size())
         fatal("Out of memory, please increase size of physical memory.");
-    return return_addr;
+    return physmem->start() + return_addr;
 }
 
 Addr
diff -x '*.pyc' -rupN /home/mjleven/tmp/m5/src/sim/system.hh ./sim/system.hh
--- /home/mjleven/tmp/m5/src/sim/system.hh	2010-10-20 13:51:49.000000000 -0600
+++ ./sim/system.hh	2011-05-27 07:38:21.000000000 -0600
@@ -89,7 +89,7 @@ class System : public SimObject
     std::vector<ThreadContext *> threadContexts;
     int _numContexts;
 
-    ThreadContext *getThreadContext(ThreadID tid)
+    virtual ThreadContext *getThreadContext(ThreadID tid)
     {
         return threadContexts[tid];
     }
@@ -228,7 +228,7 @@ class System : public SimObject
 
 #else
 
-    Addr new_page();
+    virtual Addr new_page();
 
 #endif // FULL_SYSTEM
 
