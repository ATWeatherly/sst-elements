
- Figure out where delays need to be computed
    e.g., where do latencies occur? Calculations? XML file?
    where does bandwidth come into play?
    Does 150ns in xml file translate to 150?
    Access to storage: incur latency only once, or split it

- Create bit_bucket component
    DONE Initially, just a component to consume events
    Then act on reads, do the proper delays, and route acks back

- Flits in router

Arch model
    Torus network
    A node is an endpoint of the torus network
        One or more cores per chip (with NoC), possibly multiple chips (No for now)
    NoC is also a torus but flit based; i.e., more like a memory crossbar
    Cores have local memory that can be accessed remotely through the NoC
    Each core has a connection independent of the NoC to network router which is part of the Torus
        Should we allow more than one router per chip? (Probably not.)
        Should multiple chips be able to share a router? (No for now)
    Each core has a seperate connection to shared (among cores) local NVRAM
        Need a bitbucket component. How to handle completion of writes?
    Each core has a connection to stable storage (SSD or parallel FS)
        How to handle completion of writes?
        How many cores share a channel to this storage?

- Default paramaters
    Net BW 2.0 GB/s
    Net latency 4 us

    Node BW 10 GB/s
    Node latency 200 ns

- Make ghost_pattern.cc code more modular to make it easier to expand

- Play with component weight

- Implement checkpointing
    - Coordinated
    - Uncoordinated with pessimistic msg logging
    - RAID

- More patterns
    - FFT
    - Master/Slave
    - Integer Sort (IS)

- Metrics
    - Decide on what metrics to collect
	- Power and temp for routers
	- Application run time
	- Storage size for logs and checkpoints

    - Collect metrics at end of simulation and print


DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE

- ghost_pattern
    DONE Create handlers for NETWORK, NoC, (and NVRAM, STORAGE)
    DONE Update routing algorithm

- genPatterns
    DONE If X * Y = 1, don't generate aggregator and links to it
    DONE if x * y = 1, don't generate NoC
    DONE Link between net aggregator and net router
    DONE Aggregators for NVRAMlocal and StableStorage
    DONE Select wormhole or flit-based for each router

- Router model needs to implement a getPower method
    Basically number of port accesses since last power query
    Introspector will call this periodically

- Power parameters in genPattern

- Multiple generators per router
    - Will messages between "cores" still go through router?
	For now, yes, but we make the links between routers
	and pattern generators much faster to emulate intra-node
	speeds....

