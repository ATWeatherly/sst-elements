
#include <vector>

#include "sst_config.h"
#include "sst/core/serialization/element.h"
#include "sst/core/element.h"

#include "nbprefetch.h"
#include <stdint.h>

using namespace SST;
using namespace SST::Interfaces;
using namespace SST::Cassini;

NextBlockPrefetcher::NextBlockPrefetcher(ComponentId_t id, Params_t& params) :
	Component(id) {

	cpuLink = configureLink( "cpuLink", "1ns",
		new Event::Handler<NextBlockPrefetcher>(this, &NextBlockPrefetcher::handleCPULinkEvent));
	memoryLink = configureLink( "memoryLink", "1ns",
		new Event::Handler<NextBlockPrefetcher>(this, &NextBlockPrefetcher::handleMemoryLinkEvent));
	cacheCPULink = configureLink( "cacheCPULink", "1ns",
		new Event::Handler<NextBlockPrefetcher>(this, &NextBlockPrefetcher::handleCacheToCPUEvent));
	cacheMemoryLink = configureLink( "cacheMemoryLink", "1ns",
		new Event::Handler<NextBlockPrefetcher>(this, &NextBlockPrefetcher::handleCacheToMemoryEvent));

	maximumPending = 4;
	if ( params.find("pending") != params.end() ) {
		maximumPending = strtol( params[ "pending" ].c_str(), NULL, 0 );
        }

	blockSize = 64;
	if ( params.find("blockSize") != params.end() ) {
		blockSize = strtol( params[ "blockSize" ].c_str(), NULL, 0 );
        }

	blocksAhead = 1;
	if ( params.find("blocksAhead") != params.end() ) {
		maximumPending = strtol( params[ "blocksAhead" ].c_str(), NULL, 0 );
        }

	maxAddr = 0xffffffffffffffff;
	if ( params.find("maxAddr") != params.end() ) {
		maxAddr = strtol( params[ "maxAddr" ].c_str(), NULL, 0 );
        }
	
}

void NextBlockPrefetcher::handleCPULinkEvent(SST::Event* event) {
	//std::cout << "NextBlockPrefetcher: recv event from CPU at: " <<
	//	getCurrentSimTimeNano() << "ns, sending to the cache..." << std::endl;

	cacheCPULink->send(event);
}

void NextBlockPrefetcher::handleMemoryLinkEvent(SST::Event* event) {
	//std::cout << "NextBlockPrefetcher: recv event from memory at: " <<
	//	getCurrentSimTimeNano() << "ns, sending to the cache..." << std::endl;

	cacheMemoryLink->send(event);
}

void NextBlockPrefetcher::handleCacheToCPUEvent(SST::Event* event) {
	//std::cout << "NextBlockPrefetcher: recv event from cache (to go to the CPU) at: " <<
	//	getCurrentSimTimeNano() << "ns, sending to the CPU..." << std::endl;

	bool send_to_cpu = true;

	MemEvent* memEvent = dynamic_cast<MemEvent*>(event);

	if(memEvent) {
		//std::cout << "NextBlockPrefetcher: evCompID=" << memEvent->getID().first << ", evCompID=" << memEvent->getID().second <<
		//	", addr=" << memEvent->getAddr() << " resp2ID=" << memEvent->getResponseToID().first <<
		//	", resp2CompID=" << memEvent->getResponseToID().second << std::endl;

		// Send back to the CPU if the event is owned by the them otherwise it
		// was generated by us and we can throw the address out of our prefetching
		// list
		if(memEvent->getResponseToID().second != getId()) {
			cpuLink->send(event);
		} else {
			pendingPrefAddr.erase(memEvent->getAddr());
			delete event;
		}
	} else {
		cpuLink->send(event);
	}
}

void NextBlockPrefetcher::handleCacheToMemoryEvent(SST::Event* event) {
	std::cout << "NextBlockPrefetcher: recv event from cache (to go to the memory) at: " <<
		getCurrentSimTimeNano() << "ns, sending to the memory..." << std::endl;

	memoryLink->send(event);

	// this means that this was a cache miss by this stage, we need to trap this memory
	// address and then request the next block.
	MemEvent* memEvent = dynamic_cast<MemEvent*>(event);

	if(memEvent) {
		std::cout << "NextBlockPrefetcher: considering prefetch evIDRes(2)=" <<
			memEvent->getResponseToID().second << " myID=" <<
			this->getId() << " evID(2)=" << memEvent->getID().second << 
			", getAddr=" << memEvent->getAddr() << 
			", ReqData: " << (memEvent->getCmd() == RequestData ? "true" : "false") << 
			", Src=" << memEvent->getSrc() <<
			", Dst=" << memEvent->getDst() <<
			", Flags=" << memEvent->getFlags() << 
			", getRespToID=" << memEvent->getResponseToID().first <<
			", getRespToCompID=" << memEvent->getResponseToID().second <<
			", currentReqCount=" << pendingPrefAddr.size() << std::endl;

		if(memEvent->getCmd() == RequestData) {
			Addr requestedAddr = memEvent->getAddr();
			Addr nextBlockAddr = (requestedAddr - (requestedAddr % blockSize)) + (blockSize * blocksAhead);

			std::cout << "NextBlockPrefetcher: Considering requestedAddr=" << requestedAddr << std::endl;
			set<Addr>::iterator addr_itr;

			for(addr_itr = pendingPrefAddr.begin(); addr_itr != pendingPrefAddr.end(); addr_itr++) {
				std::cout << "        Addr=" << (*addr_itr) << std::endl;
			}

			if(pendingPrefAddr.find(requestedAddr) == pendingPrefAddr.end()) {
				if((pendingPrefAddr.size() < maximumPending) &&
				   (nextBlockAddr < maxAddr)) {
					MemEvent *prefReq = new MemEvent(this, nextBlockAddr, ReadReq);

					std::cout << "NextBlockPrefetcher: created prefetch address: " <<
						nextBlockAddr << " (orig-miss: " << requestedAddr << 
						", prefReqID=" << prefReq->getID().second << ", myCompID()=" << getId() << std::endl;
					pendingPrefAddr.insert(prefReq->getAddr());
					cacheCPULink->send(prefReq);
				}
			}
		}
	}
}

bool NextBlockPrefetcher::clockTick(Cycle_t curCycle) {
	return false;
}

void NextBlockPrefetcher::finish() {

}
