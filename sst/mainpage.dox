/** @mainpage

<h1> Structural Simulation Toolkit (SST) </h1>

<h2> What it does. </h2>

Understanding the performance of large-scale, capability-class , high
performance computing (HPC) systems is possibly the most significant
challenge in the development of such a system. Because it is
impractical to construct proto-type systems for evaluation at the
desired scale, architects must turn to analytical models and
simulation to guide design decisions. Historically, the architecture
community has lacked the tools needed for a reliable and integrated
evaluation of future architectures and workloads.

The Structural Simulation Toolkit aims address this problem. The SST
provides a framework for simulating large-scale HPC systems. This
simulator allows parallel simulation of large machines at multiple
levels of detail. The SST couples models for processors, memory, and
network subsystems. The SST aims, over time, to become a standard
simulation environment for designing HPC systems by helping Industry,
Academia, and the National Labs in designing and evaluating future
architectures.

<h2> Key Interfaces for Component Writers</h2>

\subpage interfaces

<h2> Install </h2>
	
<h2> Tutorials </h2>

<h2> License </h2>

@verbatim
Copyright 2009 Sandia Corporation. Under the terms
of Contract DE-AC04-94AL85000 with Sandia Corporation, the U.S.
Government retains certain rights in this software.

Copyright (c) 2009, Sandia Corporation

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

    * Neither the name of Sandia Corporation nor the names of its
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@endverbatim

<h2> Contact </h2>

afrodri@sandia.gov

*/

/** @page interfaces Key Interfaces

<h2>The Component</h2>

The most important class for is SST::Component, the base class from
which all simulation components inherit. At the very least, a
component writer must create a class which inherits from
SST::Component and which contains a constructor. This class should be
created in a dynamic library (.so file) and should include a C-style
function of the form <componentName>AllocComponent(), which returns a
pointer to a newly instantiated component. 

SST::Component also contains useful functions for component setup
(SST::Component::Setup()), cleanup (SST::Component::Finish()), power
reporting (SST::Component::regPowerStats()), controlling when the
simulation stops (SST::Component::registerExit() and
SST::Component::unregisterExit() ), and for handling time (such as
SST::Component::getCurrentSimTime()).

<h2>Making Event Handlers</h2>

SST components use event handling functors to handle interactions with
other components (i.e. through an SST::Event sent over a SST::Link)
and recurring events (i.e. component clock ticks). The Event Handler
Class, SST::EventHandler, is templated to create either type of event
handler by creating a functor which invokes a given member function
whenever triggered. For example: 

@verbatim
NICeventHandler = new EventHandler<proc, bool, Event *>
    (this, &proc::handle_nic_events);
...
bool proc::handle_nic_events(Event *event) {
...
}
@endverbatim

creates an event handler which calls \c proc::handle_nic_events() with
an argument of type \c Event* - the SST::Event to be processed.
Similarly,

@verbatim
clockHandler = new EventHandler< proc, bool, Cycle_t>
    ( this, &proc::preTic );
@endverbatim

creates an event handler which invokes the function \c proc::preTic()
with the current cycle time. 

<h2>Using Event Handlers</h2>

Once created, an SST::EventHandler must be registered with the
simulation core. This can be done with the SST::LinkMap::LinkAdd()
function for events coming from another component, or by
SST::Component::registerClock(), for event handlers triggered by a
clock. For example, the handlers created above could be registed in
this way:

@verbatim
LinkAdd("mem0", NICeventHandler)
registerClock( "1Ghz", clockHandler );
@endverbatim

Note that SST::Component::registerClock() can have its period or
frequency expressed in SI units in a string. The allowed units are
specified in SST::TimeLord::getTimeConverter() function.

Also note that the SST::LinkMap::LinkAdd() function does not require
an event handler if the recieving component uses the "event pull"
mechanism with SST::Link::Recv().

<h2>Links</h2>

SST::Component s use SST::Link to communicate by passing events. An
SST::Link is specified in the XML file use to configure the
simulation, and must also be added to each component which uses it by
the SST::LinkMap::LinkAdd() function. For example, 

@verbatim
<component id="processor">
 <genericProc>
   <links>
    <link id="cpu2mem">
      <params>
       <name>mem0</name>
       <lat>1 ns</lat>
      </params>
    </link>
  </links>
 </genericProc>
</component>

<component id="memory">
 <DRAMSimC>
  <links>
   <link id="cpu2mem">
    <params>
     <name>bus</name>
     <lat>1 ns</lat>
    </params>
  </link>
 </links>
 </DRAMSimC>
</component>
@endverbatim

specifies two components, a processor and a memory. These components
are connected by an SST::Link. Each \c link block contains an \c id,
a \c name, and a \c lat : 

   - The \c id is a global identifier for the SST::Link object. Since
     multiple components connect to the link ("memory" and "processor"
     in this case), each component has a \c link block and the \c id
     is used to make it clear that they are both referencing the same
     link object.

   - The \c name specifies the local name for that component to
     reference the link. It is the string passed to the
     SST::LinkMap::LinkAdd() function to make a component connect to
     that SST::Link object.

   - The \c lat specifies the latency of the link in SI units. This is
     the minimum latency for an event to be passed from one end of the
     link to another. I.e. After the event is sent from one component
     with SST::Link::Send(), it will cause the event handler on the other
     component to be invoked after at least this period of time. More
     time can be added to this delay with different varients of the
     SST::Link::Send() function.

Other commonly used SST::Link functions are:

  - SST::Link::Send(CompEvent *event) : Send an SST::Event across the link. 

  - SST::Link::Send(SimTime_t delay, CompEvent *event) : Send an
    SST::Event with an additional delay, where the delay is in units of
    the link frequency.

  - SST::Link::Send(SimTime_t delay, TimeConverter *tc, CompEvent
    *event) : Send an SST::Event with additional delay, where the
    delay is specified in units of the SST::TimeConverter object
    supplied.

  - SST::Link::Recv() : Pull a pending SST::Event from the SST::Link.
    If there is no event handler registered with the Link, this
    function should be used to gather incoming events from the link.
    (I.e. a component "pulls" events from the link, rather than having
    them "pushed" into an event handler). 

*/
